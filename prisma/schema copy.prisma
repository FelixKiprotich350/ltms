// prisma/schema.prisma

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL") // Use environment variable to store the connection URL
}

generator client {
  provider = "prisma-client-js"
}

model ClientConfiguration {
  uuid       String   @id @default(uuid()) // UUID as a unique field
  clientName String
  salesTax   Decimal
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
}

model Person {
  uuid        String     @unique @default(uuid()) // UUID as a unique field
  firstName   String
  lastName    String
  email       String     @unique
  phoneNumber String?    @unique
  dateOfBirth DateTime?
  address     String?
  gender      String?
  nationality String?
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt
  LtmsUser    LtmsUser[]
}

model LtmsUser {
  uuid           String                  @id @default(uuid()) // UUID as a unique field
  username       String                  @unique
  email          String                  @unique
  loginStatus    String                  @default("ENABLED")
  approvalStatus String                  @default("PENDING")
  passwordHash   String
  Person         Person                  @relation(fields: [personUuid], references: [uuid])
  personUuid     String                  @unique //fk to person uuid
  UserRole       UserRole?               @relation(fields: [userRoleUuid], references: [uuid])
  userRoleUuid   String
  departmentUuid String?
  department     OrganisationDepartment? @relation(fields: [departmentUuid], references: [uuid])
  groups         UserGroupMember[]
  letters        Letter[]                @relation("LetterSender")
  approvals      Approval[]
  logs           Log[]
  notifications  Notification[]
  // LettersOfRecipient Letter[]                @relation("LetterRecipient")
  // LettersOfUser      Letter[]                @relation("LetterUser")
  createdAt      DateTime                @default(now())
  updatedAt      DateTime                @updatedAt
  // Letter             Letter[]
}

model UserRole {
  uuid        String       @id @default(uuid()) // UUID as a unique field
  name        String       @unique
  description String?
  users       LtmsUser[]
  permissions Permission[]
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt
}

model Permission {
  id          Int        @id @default(autoincrement()) // Int as PK
  uuid        String     @unique @default(uuid()) // UUID as a unique field
  name        String     @unique
  description String?
  roles       UserRole[]
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt
}

//organisation
model OrganisationDepartment {
  uuid         String     @id @default(uuid())
  name         String     @unique
  activeStatus String
  description  String
  Users        LtmsUser[]
  Letters      Letter[]   @relation("LetterDepartment")
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt
  // RecipientsMaster RecipientsMaster[]

  RecipientsMaster RecipientsMaster[] @relation(name: "Departmentofrecipient")
}

model DepartmentRole {
  uuid        String   @id @default(uuid()) // UUID as a unique field
  name        String   @unique
  description String?
  // users       LtmsUser[]
  // permissions Permission[]
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

//letter request
model Letter {
  uuid                 String                  @id @default(uuid())
  referenceNo          String                  @unique
  subject              String
  body                 String
  letterCategoryId     String
  letterCategory       LetterCategory          @relation(fields: [letterCategoryId], references: [uuid])
  senderUserUuid       String
  senderUser           LtmsUser                @relation("LetterSender", fields: [senderUserUuid], references: [uuid])
  senderDepartmentUuid String
  senderDepartment     OrganisationDepartment? @relation("LetterDepartment", fields: [senderDepartmentUuid], references: [uuid])
  status               LetterStatus            @default(PENDING)
  approvals            Approval[]
  attachments          Attachment[]
  logs                 Log[]
  LetterRecipients     LetterRecipients[]      @relation(name: "LetterstoRecipients")
  createdAt            DateTime                @default(now())
  updatedAt            DateTime                @updatedAt
}

model LetterCategory {
  uuid        String   @unique @default(uuid()) // UUID as a unique field
  name        String
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  Letter      Letter[]
}

model RecipientsMaster {
  uuid                String                  @unique @default(uuid()) // UUID as a unique field
  recipientType       String
  recipientUuid       String
  createdAt           DateTime                @default(now())
  updatedAt           DateTime                @updatedAt
  DepartmentRecipient OrganisationDepartment? @relation(name: "Departmentofrecipient", fields: [recipientUuid], references: [uuid])
  letterUuid          String?
  LetterRecipients    LetterRecipients[]
}

model LetterRecipients {
  uuid          String           @unique @default(uuid()) // UUID as a unique field
  letterUuid    String
  recipientUuid String
  createdAt     DateTime         @default(now())
  updatedAt     DateTime         @updatedAt
  // Letter        Letter           @relation(name: "LetterstoRecipients", fields: [letterUuid], references: [uuid])
  Recipient     RecipientsMaster @relation(fields: [recipientUuid], references: [uuid])
  Letter        Letter           @relation(name: "LetterstoRecipients", fields: [letterUuid], references: [uuid])
}

model UserGroup {
  uuid    String            @id @default(uuid())
  name    String            @unique
  members UserGroupMember[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model UserGroupMember {
  id      String    @id @default(uuid())
  userId  String
  user    LtmsUser  @relation(fields: [userId], references: [uuid])
  groupId String
  group   UserGroup @relation(fields: [groupId], references: [uuid])
}

enum LetterStatus {
  PENDING
  APPROVED
  REJECTED
  FORWARDED
  COMPLETED
}

model Approval {
  id        String         @id @default(uuid())
  letterId  String
  letter    Letter         @relation(fields: [letterId], references: [uuid])
  userId    String
  user      LtmsUser       @relation(fields: [userId], references: [uuid])
  status    ApprovalStatus @default(PENDING)
  remarks   String?
  step      Int // Multi-level approval sequence
  deadline  DateTime? // Auto-escalation based on deadline
  escalated Boolean        @default(false) // Mark if escalated

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

enum ApprovalStatus {
  PENDING
  APPROVED
  REJECTED
}

model Attachment {
  id       String @id @default(uuid())
  letterId String
  letter   Letter @relation(fields: [letterId], references: [uuid])
  fileUrl  String
  fileType String
  fileName String

  createdAt DateTime @default(now())
}

model Notification {
  id      String           @id @default(uuid())
  userId  String
  user    LtmsUser         @relation(fields: [userId], references: [uuid])
  message String
  read    Boolean          @default(false)
  type    NotificationType
  sentAt  DateTime         @default(now())

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

enum NotificationType {
  EMAIL
  SMS
  SYSTEM
}

model Log {
  id       String   @id @default(uuid())
  letterId String
  letter   Letter   @relation(fields: [letterId], references: [uuid])
  userId   String
  user     LtmsUser @relation(fields: [userId], references: [uuid])
  action   String

  createdAt DateTime @default(now())
}
